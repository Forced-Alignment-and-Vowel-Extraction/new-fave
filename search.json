[
  {
    "objectID": "usage/getting_started.html",
    "href": "usage/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "# bash\npip install new-fave",
    "crumbs": [
      "Home",
      "Usage",
      "Getting Started"
    ]
  },
  {
    "objectID": "usage/getting_started.html#audio-textgrid",
    "href": "usage/getting_started.html#audio-textgrid",
    "title": "Getting Started",
    "section": "Audio + TextGrid",
    "text": "Audio + TextGrid\nSee fave_audio_textgrid and write_data. And if desired, SpeakerCollection.\nfrom new_fave import fave_audio_textgrid, write_data\n\nspeakers = fave_audio_textgrid(\n    audio_path = \"speaker1.wav\",\n    textgrid_path = \"speaker2.TextGrid\",\n    ## all optional args below\n    speakers = \"all\",\n    recode_rules = \"cmu2labov\",\n    labelset_parser = \"cmu_parser\",\n    point_heuristic = \"fave\",\n    ft_config = \"default\"\n)\n\nwrite_data(\n    speakers, \n    destination = \"output_dir\"\n)",
    "crumbs": [
      "Home",
      "Usage",
      "Getting Started"
    ]
  },
  {
    "objectID": "usage/getting_started.html#corpus",
    "href": "usage/getting_started.html#corpus",
    "title": "Getting Started",
    "section": "Corpus",
    "text": "Corpus\nSee fave_corpus and write_data. And if desired, SpeakerCollection.\nfrom new_fave import fave_corpus, write_data\n\nspeakers = fave_audio_textgrid(\n    corpus_path = \"corpus/\",\n    ## all optional args below\n    speakers = \"all\",\n    recode_rules = \"cmu2labov\",\n    labelset_parser = \"cmu_parser\",\n    point_heuristic = \"fave\",\n    ft_config = \"default\"\n)\n\nwrite_data(\n    speakers, \n    destination = \"output_dir\"\n)",
    "crumbs": [
      "Home",
      "Usage",
      "Getting Started"
    ]
  },
  {
    "objectID": "usage/getting_started.html#subcorpora",
    "href": "usage/getting_started.html#subcorpora",
    "title": "Getting Started",
    "section": "Subcorpora",
    "text": "Subcorpora\nSee fave_subcorpora and write_data. And if desired, SpeakerCollection.\nfrom new_fave import fave_subcorpora, write_data\n\nspeakers = fave_subcorpora(\n    subcorpora_glob = \"project/speakers/*/\",\n    ## all optional args below\n    speakers = \"all\",\n    recode_rules = \"cmu2labov\",\n    labelset_parser = \"cmu_parser\",\n    point_heuristic = \"fave\",\n    ft_config = \"default\"\n)\n\nwrite_data(\n    speakers, \n    destination = \"output_dir\"\n)",
    "crumbs": [
      "Home",
      "Usage",
      "Getting Started"
    ]
  },
  {
    "objectID": "dev_plan/new-fave-approach.html",
    "href": "dev_plan/new-fave-approach.html",
    "title": "new-fave Approach",
    "section": "",
    "text": "Currently, I have a few classes and functions written up to allow for a hybrid fave-like and fasttrack-like formant track optimization."
  },
  {
    "objectID": "reference/utils.local_resources.local_resources.html",
    "href": "reference/utils.local_resources.local_resources.html",
    "title": "utils.local_resources.local_resources",
    "section": "",
    "text": "utils.local_resources.local_resources()\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecodes\ndict\nRecode options. Contains \"cmu2phila\" and \"cmu2labov\"\n\n\nparsers\ndict\nLabelset parsers. Contains \"cmu_parser\"\n\n\nheursitics\ndict\nMeasurement point heuristics. Contains \"fave\"\n\n\nfasttrack_config\ndict\nFastTrack config. Contains \"default\"",
    "crumbs": [
      "Built-in resources",
      "utils.local_resources.local_resources"
    ]
  },
  {
    "objectID": "reference/utils.local_resources.local_resources.html#attributes",
    "href": "reference/utils.local_resources.local_resources.html#attributes",
    "title": "utils.local_resources.local_resources",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nrecodes\ndict\nRecode options. Contains \"cmu2phila\" and \"cmu2labov\"\n\n\nparsers\ndict\nLabelset parsers. Contains \"cmu_parser\"\n\n\nheursitics\ndict\nMeasurement point heuristics. Contains \"fave\"\n\n\nfasttrack_config\ndict\nFastTrack config. Contains \"default\"",
    "crumbs": [
      "Built-in resources",
      "utils.local_resources.local_resources"
    ]
  },
  {
    "objectID": "reference/VowelMeasurement.html",
    "href": "reference/VowelMeasurement.html",
    "title": "VowelMeasurement",
    "section": "",
    "text": "VowelMeasurement(self, track, heuristic=Heuristic())\nA class used to represent a vowel measurement.\n\n\nCertain properties of a VowelMeasurement instance are set by its membership within a VowelClass and that VowelClass’s membership in a VowelClassCollection. These memberships are best managed by passing a list of VowelMeasurements to SpeakerCollection.\nvowel_measurements = [VowelMeasurement(t) for t in fasttrack_tracks]\nspeakers = SpeakerCollection(vowel_measurements)\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrack\nfasttrackpy.CandidateTracks\nA fasttrackpy.CandidateTrracks object\nrequired\n\n\nheuristic\nHeuristic\nA point measurement Heuristic to use. Defaults to Heuristic().\nHeuristic()\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrack\nfasttrackpy.CandidateTracks\nan object of CandidateTracks class\n\n\ncandidates\nlist\nlist of candidates for the track\n\n\nheuristic\nHeuristic\nan object of Heuristic class (default is Heuristic())\n\n\nvowel_class\nVowelClass\nThe containing VowelClass object\n\n\nformant_array\nFormantArray\nA FormantArray object\n\n\nfile_name\nstr\nname of the file of the track\n\n\ngroup\nstr\nTierGroup of the track\n\n\nid\nstr\nid of the track\n\n\ninterval\naligned_textgrid.SequenceInterval\ninterval of the track\n\n\nlabel\nstr\nlabel of the track\n\n\nn_formants\nint\nnumber of formants in the track\n\n\noptimized\nint\nThe number of optimization iterations the vowel measurement has been through.\n\n\nwinner\n\nfasttrackpy.OneTrack The winning formant track\n\n\nwinner_index\nint\nThe index of the winning formant track\n\n\nerror_log_prob\nnp.array\nA conversion of the log-mean-squared-error to a log-probabilities, based on an empirical cumulative density function.\n\n\ncand_errors\nnp.array\nA numpy array of the log-mean-squared-errors for each candidate track.\n\n\ncand_mahals\nnp.array\nThe mahalanobis distance across DCT parameters for each candidate from the vowel system distribution.\n\n\ncand_mahal_log_prob\nnp.array\nA conversion of cand_mahals to log-probabilies.\n\n\ncand_max_formants\nnp.array\nA numpy array of the maximum formants for this VowelMeasurement\n\n\ncand_params\nnp.array\nA numpy array of the candidate track DCT parameters.\n\n\nmax_formant_log_prob\nnp.array\nA conversion of max_formant_mahal to log-probabilities.\n\n\nmax_formant_mahal\nnp.array\nThe mahalanobis distance of each maximum formant to the speaker’s entire distribution.\n\n\npoint_measure\npl.DataFrame\nA polars dataframe of the point measurement for this vowel.\n\n\nvm_context\npl.DataFrame\nA polars dataframe of contextual information for the vowel measurement.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_tracks_df\nReturn a DataFrame of the formant tracks\n\n\nto_param_df\nReturn DataFrame of formant DCT parameters.\n\n\nto_point_df\nReturn a DataFrame of point measurements\n\n\n\n\n\nVowelMeasurement.to_tracks_df()\nReturn a DataFrame of the formant tracks\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA dataframe with formant track data.\n\n\n\n\n\n\n\nVowelMeasurement.to_param_df(output='log_param')\nReturn DataFrame of formant DCT parameters.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of formant DCT parameters\n\n\n\n\n\n\n\nVowelMeasurement.to_point_df()\nReturn a DataFrame of point measurements\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of vowel point measures.",
    "crumbs": [
      "Vowel Measurements",
      "VowelMeasurement"
    ]
  },
  {
    "objectID": "reference/VowelMeasurement.html#intended-usage",
    "href": "reference/VowelMeasurement.html#intended-usage",
    "title": "VowelMeasurement",
    "section": "",
    "text": "Certain properties of a VowelMeasurement instance are set by its membership within a VowelClass and that VowelClass’s membership in a VowelClassCollection. These memberships are best managed by passing a list of VowelMeasurements to SpeakerCollection.\nvowel_measurements = [VowelMeasurement(t) for t in fasttrack_tracks]\nspeakers = SpeakerCollection(vowel_measurements)",
    "crumbs": [
      "Vowel Measurements",
      "VowelMeasurement"
    ]
  },
  {
    "objectID": "reference/VowelMeasurement.html#parameters",
    "href": "reference/VowelMeasurement.html#parameters",
    "title": "VowelMeasurement",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntrack\nfasttrackpy.CandidateTracks\nA fasttrackpy.CandidateTrracks object\nrequired\n\n\nheuristic\nHeuristic\nA point measurement Heuristic to use. Defaults to Heuristic().\nHeuristic()",
    "crumbs": [
      "Vowel Measurements",
      "VowelMeasurement"
    ]
  },
  {
    "objectID": "reference/VowelMeasurement.html#attributes",
    "href": "reference/VowelMeasurement.html#attributes",
    "title": "VowelMeasurement",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntrack\nfasttrackpy.CandidateTracks\nan object of CandidateTracks class\n\n\ncandidates\nlist\nlist of candidates for the track\n\n\nheuristic\nHeuristic\nan object of Heuristic class (default is Heuristic())\n\n\nvowel_class\nVowelClass\nThe containing VowelClass object\n\n\nformant_array\nFormantArray\nA FormantArray object\n\n\nfile_name\nstr\nname of the file of the track\n\n\ngroup\nstr\nTierGroup of the track\n\n\nid\nstr\nid of the track\n\n\ninterval\naligned_textgrid.SequenceInterval\ninterval of the track\n\n\nlabel\nstr\nlabel of the track\n\n\nn_formants\nint\nnumber of formants in the track\n\n\noptimized\nint\nThe number of optimization iterations the vowel measurement has been through.\n\n\nwinner\n\nfasttrackpy.OneTrack The winning formant track\n\n\nwinner_index\nint\nThe index of the winning formant track\n\n\nerror_log_prob\nnp.array\nA conversion of the log-mean-squared-error to a log-probabilities, based on an empirical cumulative density function.\n\n\ncand_errors\nnp.array\nA numpy array of the log-mean-squared-errors for each candidate track.\n\n\ncand_mahals\nnp.array\nThe mahalanobis distance across DCT parameters for each candidate from the vowel system distribution.\n\n\ncand_mahal_log_prob\nnp.array\nA conversion of cand_mahals to log-probabilies.\n\n\ncand_max_formants\nnp.array\nA numpy array of the maximum formants for this VowelMeasurement\n\n\ncand_params\nnp.array\nA numpy array of the candidate track DCT parameters.\n\n\nmax_formant_log_prob\nnp.array\nA conversion of max_formant_mahal to log-probabilities.\n\n\nmax_formant_mahal\nnp.array\nThe mahalanobis distance of each maximum formant to the speaker’s entire distribution.\n\n\npoint_measure\npl.DataFrame\nA polars dataframe of the point measurement for this vowel.\n\n\nvm_context\npl.DataFrame\nA polars dataframe of contextual information for the vowel measurement.",
    "crumbs": [
      "Vowel Measurements",
      "VowelMeasurement"
    ]
  },
  {
    "objectID": "reference/VowelMeasurement.html#methods",
    "href": "reference/VowelMeasurement.html#methods",
    "title": "VowelMeasurement",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_tracks_df\nReturn a DataFrame of the formant tracks\n\n\nto_param_df\nReturn DataFrame of formant DCT parameters.\n\n\nto_point_df\nReturn a DataFrame of point measurements\n\n\n\n\n\nVowelMeasurement.to_tracks_df()\nReturn a DataFrame of the formant tracks\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA dataframe with formant track data.\n\n\n\n\n\n\n\nVowelMeasurement.to_param_df(output='log_param')\nReturn DataFrame of formant DCT parameters.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of formant DCT parameters\n\n\n\n\n\n\n\nVowelMeasurement.to_point_df()\nReturn a DataFrame of point measurements\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of vowel point measures.",
    "crumbs": [
      "Vowel Measurements",
      "VowelMeasurement"
    ]
  },
  {
    "objectID": "reference/optimize.optimize.html",
    "href": "reference/optimize.optimize.html",
    "title": "optimize.optimize",
    "section": "",
    "text": "optimize.optimize\n\n\n\n\n\nName\nDescription\n\n\n\n\noptimize_one_measure\nThis function optimizes a given vowel measurement based on the\n\n\noptimize_vowel_measures\nOptimize a list of VowelMeasurements.\n\n\nrun_optimize\nRepeatedly run optimization until either max_iter is reached,\n\n\n\n\n\noptimize.optimize.optimize_one_measure(vowel_measurement, optim_params=['cand_mahal', 'max_formant'])\nThis function optimizes a given vowel measurement based on the specified optimization parameters. The optimization parameters can include ‘cand_mahal’ and ‘max_formant’.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvowel_measurement\nVowelMeasurement\nThe VowelMeasurement to optimize\nrequired\n\n\noptim_params\nlist[Literal[‘cand_mahal’, ‘max_formant’]]\nThe optimization parameters to use. Defaults to [“cand_mahal”, “max_formant”].\n['cand_mahal', 'max_formant']\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of the winning candidate.\n\n\n\n\n\n\n\noptimize.optimize.optimize_vowel_measures(vowel_measurements, optim_params=['cand_mahal', 'max_formant'])\nOptimize a list of VowelMeasurements.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvowel_measurements\nlist[VowelMeasurement]\nThe list of vowel measurements to optimize\nrequired\n\n\noptim_params\nlist[Literal[‘cand_mahal’, ‘max_formant’]]\nThe optimization parameters to use. Defaults to [“cand_mahal”, “max_formant”].\n['cand_mahal', 'max_formant']\n\n\n\n\n\n\n\noptimize.optimize.run_optimize(vowel_system, optim_params=['cand_mahal', 'max_formant'], max_iter=10)\nRepeatedly run optimization until either max_iter is reached, or the difference between two iterations becomes small.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvowel_system\nVowelClassCollection\nThe vowel space to be optimized\nrequired\n\n\noptim_params\nlist\nThe parameters to use for optimization. Defaults to [“cand_mahal”, “max_formant”].\n['cand_mahal', 'max_formant']\n\n\nmax_iter\nint\nThe maximum number of iterations to run. Defaults to 10.\n10",
    "crumbs": [
      "Optimization",
      "optimize.optimize"
    ]
  },
  {
    "objectID": "reference/optimize.optimize.html#functions",
    "href": "reference/optimize.optimize.html#functions",
    "title": "optimize.optimize",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\noptimize_one_measure\nThis function optimizes a given vowel measurement based on the\n\n\noptimize_vowel_measures\nOptimize a list of VowelMeasurements.\n\n\nrun_optimize\nRepeatedly run optimization until either max_iter is reached,\n\n\n\n\n\noptimize.optimize.optimize_one_measure(vowel_measurement, optim_params=['cand_mahal', 'max_formant'])\nThis function optimizes a given vowel measurement based on the specified optimization parameters. The optimization parameters can include ‘cand_mahal’ and ‘max_formant’.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvowel_measurement\nVowelMeasurement\nThe VowelMeasurement to optimize\nrequired\n\n\noptim_params\nlist[Literal[‘cand_mahal’, ‘max_formant’]]\nThe optimization parameters to use. Defaults to [“cand_mahal”, “max_formant”].\n['cand_mahal', 'max_formant']\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of the winning candidate.\n\n\n\n\n\n\n\noptimize.optimize.optimize_vowel_measures(vowel_measurements, optim_params=['cand_mahal', 'max_formant'])\nOptimize a list of VowelMeasurements.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvowel_measurements\nlist[VowelMeasurement]\nThe list of vowel measurements to optimize\nrequired\n\n\noptim_params\nlist[Literal[‘cand_mahal’, ‘max_formant’]]\nThe optimization parameters to use. Defaults to [“cand_mahal”, “max_formant”].\n['cand_mahal', 'max_formant']\n\n\n\n\n\n\n\noptimize.optimize.run_optimize(vowel_system, optim_params=['cand_mahal', 'max_formant'], max_iter=10)\nRepeatedly run optimization until either max_iter is reached, or the difference between two iterations becomes small.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvowel_system\nVowelClassCollection\nThe vowel space to be optimized\nrequired\n\n\noptim_params\nlist\nThe parameters to use for optimization. Defaults to [“cand_mahal”, “max_formant”].\n['cand_mahal', 'max_formant']\n\n\nmax_iter\nint\nThe maximum number of iterations to run. Defaults to 10.\n10",
    "crumbs": [
      "Optimization",
      "optimize.optimize"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Different patterns for processing data\n\n\n\nfave_audio_textgrid\nProcess a single audio/textgrid pair.\n\n\nfave_corpus\nProcess a corpus directory.\n\n\nfave_subcorpora\nProcess multiple subcorpora\n\n\n\n\n\n\n\n\n\nwrite_data\nSave data.\n\n\n\n\n\n\n\n\n\nutils.local_resources.local_resources\n\n\n\n\n\n\n\n\n\n\nspeaker.speaker.Speaker\nThis is a class to represent speaker information.\n\n\n\n\n\n\nFunctions for optimizing formant measurements\n\n\n\noptimize.optimize\n\n\n\n\n\n\n\nVowel Measurements\n\n\n\nVowelMeasurement\nA class used to represent a vowel measurement.\n\n\nVowelClass\nA class used to represent a vowel class.\n\n\nVowelClassCollection\nA class for an entire vowel system.\n\n\nSpeakerCollection\nA class to represent the vowel system of all",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#processing-patterns",
    "href": "reference/index.html#processing-patterns",
    "title": "Function reference",
    "section": "",
    "text": "Different patterns for processing data\n\n\n\nfave_audio_textgrid\nProcess a single audio/textgrid pair.\n\n\nfave_corpus\nProcess a corpus directory.\n\n\nfave_subcorpora\nProcess multiple subcorpora",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#writers",
    "href": "reference/index.html#writers",
    "title": "Function reference",
    "section": "",
    "text": "write_data\nSave data.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#built-in-resources",
    "href": "reference/index.html#built-in-resources",
    "title": "Function reference",
    "section": "",
    "text": "utils.local_resources.local_resources",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#speaker-files",
    "href": "reference/index.html#speaker-files",
    "title": "Function reference",
    "section": "",
    "text": "speaker.speaker.Speaker\nThis is a class to represent speaker information.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#optimization",
    "href": "reference/index.html#optimization",
    "title": "Function reference",
    "section": "",
    "text": "Functions for optimizing formant measurements\n\n\n\noptimize.optimize",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#vowel-measurements",
    "href": "reference/index.html#vowel-measurements",
    "title": "Function reference",
    "section": "",
    "text": "Vowel Measurements\n\n\n\nVowelMeasurement\nA class used to represent a vowel measurement.\n\n\nVowelClass\nA class used to represent a vowel class.\n\n\nVowelClassCollection\nA class for an entire vowel system.\n\n\nSpeakerCollection\nA class to represent the vowel system of all",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/VowelClassCollection.html",
    "href": "reference/VowelClassCollection.html",
    "title": "VowelClassCollection",
    "section": "",
    "text": "VowelClassCollection(self, track_list)\nA class for an entire vowel system.\n\n\nIt is a subclass of defaultdict, so it can be keyed by vowel class label.\nvowel_measurements = [VowelMeasurement(t) for t in fasttrack_tracks]\nvowel_system = VowelClassCollection(vowel_measurements)\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrack_list\nlist[VowelMeasurement]\nA list of VowelMeasurements.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmaximum_formant_cov\nnp.array\nThe covariance matrix for the winners maximum formant across the entire vowel system\n\n\nmaximum_formant_means\nnp.array\nThe mean maximum formant for the winners across the entire vowel system\n\n\nmax_formant_icov\nnp.array\nThe inverse covariance matrix for the winners maximum formant across the entire vowel system\n\n\nparams_covs\nnp.array\nThe covariance matrix for the winners’ DCT parameters.\n\n\nparams_icov\nnp.array\nThe inverse covariance matrix for the winners’ DCT parameters.\n\n\nparams_means\nnp.array\nAn np.array for the winners’ DCT parameters in the entire vowel system.\n\n\nvowel_measurements\nlist[VowelMeasurement]\nA list of all vowel measurements in the vowel system\n\n\nwinner_formants\nnp.array\nAn np.array for the formants for the winners in the entire vowel system.\n\n\nwinner_params\nnp.array\nAn np.array of DCT parameters for the winners in entire vowel system.\n\n\nwinners\nlist[fasttrackpy.OneTrack]\nThe winning fasttrackpy.OneTrack for the entire vowel system\n\n\nwinners_maximum_formant\nnp.array\nAn np.array of the maximum formants for the winners in the entire vowel system\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_tracks_df\nReturn a DataFrame of the formant tracks\n\n\nto_param_df\nReturn DataFrame of formant DCT parameters.\n\n\nto_point_df\nReturn a DataFrame of point measurements\n\n\n\n\n\nVowelClassCollection.to_tracks_df()\nReturn a DataFrame of the formant tracks\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA dataframe with formant track data.\n\n\n\n\n\n\n\nVowelClassCollection.to_param_df(output='log_param')\nReturn DataFrame of formant DCT parameters.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of formant DCT parameters\n\n\n\n\n\n\n\nVowelClassCollection.to_point_df()\nReturn a DataFrame of point measurements\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of vowel point measures.",
    "crumbs": [
      "Vowel Measurements",
      "VowelClassCollection"
    ]
  },
  {
    "objectID": "reference/VowelClassCollection.html#intended-usage",
    "href": "reference/VowelClassCollection.html#intended-usage",
    "title": "VowelClassCollection",
    "section": "",
    "text": "It is a subclass of defaultdict, so it can be keyed by vowel class label.\nvowel_measurements = [VowelMeasurement(t) for t in fasttrack_tracks]\nvowel_system = VowelClassCollection(vowel_measurements)",
    "crumbs": [
      "Vowel Measurements",
      "VowelClassCollection"
    ]
  },
  {
    "objectID": "reference/VowelClassCollection.html#parameters",
    "href": "reference/VowelClassCollection.html#parameters",
    "title": "VowelClassCollection",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntrack_list\nlist[VowelMeasurement]\nA list of VowelMeasurements.\nrequired",
    "crumbs": [
      "Vowel Measurements",
      "VowelClassCollection"
    ]
  },
  {
    "objectID": "reference/VowelClassCollection.html#attributes",
    "href": "reference/VowelClassCollection.html#attributes",
    "title": "VowelClassCollection",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nmaximum_formant_cov\nnp.array\nThe covariance matrix for the winners maximum formant across the entire vowel system\n\n\nmaximum_formant_means\nnp.array\nThe mean maximum formant for the winners across the entire vowel system\n\n\nmax_formant_icov\nnp.array\nThe inverse covariance matrix for the winners maximum formant across the entire vowel system\n\n\nparams_covs\nnp.array\nThe covariance matrix for the winners’ DCT parameters.\n\n\nparams_icov\nnp.array\nThe inverse covariance matrix for the winners’ DCT parameters.\n\n\nparams_means\nnp.array\nAn np.array for the winners’ DCT parameters in the entire vowel system.\n\n\nvowel_measurements\nlist[VowelMeasurement]\nA list of all vowel measurements in the vowel system\n\n\nwinner_formants\nnp.array\nAn np.array for the formants for the winners in the entire vowel system.\n\n\nwinner_params\nnp.array\nAn np.array of DCT parameters for the winners in entire vowel system.\n\n\nwinners\nlist[fasttrackpy.OneTrack]\nThe winning fasttrackpy.OneTrack for the entire vowel system\n\n\nwinners_maximum_formant\nnp.array\nAn np.array of the maximum formants for the winners in the entire vowel system",
    "crumbs": [
      "Vowel Measurements",
      "VowelClassCollection"
    ]
  },
  {
    "objectID": "reference/VowelClassCollection.html#methods",
    "href": "reference/VowelClassCollection.html#methods",
    "title": "VowelClassCollection",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_tracks_df\nReturn a DataFrame of the formant tracks\n\n\nto_param_df\nReturn DataFrame of formant DCT parameters.\n\n\nto_point_df\nReturn a DataFrame of point measurements\n\n\n\n\n\nVowelClassCollection.to_tracks_df()\nReturn a DataFrame of the formant tracks\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA dataframe with formant track data.\n\n\n\n\n\n\n\nVowelClassCollection.to_param_df(output='log_param')\nReturn DataFrame of formant DCT parameters.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of formant DCT parameters\n\n\n\n\n\n\n\nVowelClassCollection.to_point_df()\nReturn a DataFrame of point measurements\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of vowel point measures.",
    "crumbs": [
      "Vowel Measurements",
      "VowelClassCollection"
    ]
  },
  {
    "objectID": "reference/VowelClass.html",
    "href": "reference/VowelClass.html",
    "title": "VowelClass",
    "section": "",
    "text": "VowelClass(self, label, tracks)\nA class used to represent a vowel class.\n\n\nVowelClass subclasses collections.abc.Sequence, so it is indexable. While it can be created on its own, it is best to leave this up to either VowelClassCollection or SpeakerCollection.\nvowel_measurements = [VowelMeasurement(t) for t in fasttrack_tracks]\nvowel_class = VowelClass(\"ay\", vowel_measurements)\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel\nstr\nThe vowel class label\nrequired\n\n\ntracks\nlist[VowelMeasurement]\nA list of VowelMeasurements\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlabel\nstr\nlabel of the vowel class\n\n\ntracks\nlist\nA list of VowelMeasurements\n\n\nvowel_system\nVowelClassCollection\nA the containing vowel system\n\n\nwinners\nlist[fasttrackpy.OneTrack]\nA list of winner OneTracks from the vowel class\n\n\nwinner_params\nnp.array\nAn np.array of winner DCT parameters from the vowel class.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_tracks_df\nReturn DataFrame of formanttracks.\n\n\nto_param_df\nReturn DataFrame of formant DCT parameters.\n\n\nto_point_df\nReturn a DataFrame of point measurements\n\n\n\n\n\nVowelClass.to_tracks_df()\nReturn DataFrame of formanttracks.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of formant tracks\n\n\n\n\n\n\n\nVowelClass.to_param_df(output='log_param')\nReturn DataFrame of formant DCT parameters.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of formant DCT parameters\n\n\n\n\n\n\n\nVowelClass.to_point_df()\nReturn a DataFrame of point measurements\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of vowel point measures.",
    "crumbs": [
      "Vowel Measurements",
      "VowelClass"
    ]
  },
  {
    "objectID": "reference/VowelClass.html#intended-usage",
    "href": "reference/VowelClass.html#intended-usage",
    "title": "VowelClass",
    "section": "",
    "text": "VowelClass subclasses collections.abc.Sequence, so it is indexable. While it can be created on its own, it is best to leave this up to either VowelClassCollection or SpeakerCollection.\nvowel_measurements = [VowelMeasurement(t) for t in fasttrack_tracks]\nvowel_class = VowelClass(\"ay\", vowel_measurements)",
    "crumbs": [
      "Vowel Measurements",
      "VowelClass"
    ]
  },
  {
    "objectID": "reference/VowelClass.html#parameters",
    "href": "reference/VowelClass.html#parameters",
    "title": "VowelClass",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nlabel\nstr\nThe vowel class label\nrequired\n\n\ntracks\nlist[VowelMeasurement]\nA list of VowelMeasurements\nrequired",
    "crumbs": [
      "Vowel Measurements",
      "VowelClass"
    ]
  },
  {
    "objectID": "reference/VowelClass.html#attributes",
    "href": "reference/VowelClass.html#attributes",
    "title": "VowelClass",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nlabel\nstr\nlabel of the vowel class\n\n\ntracks\nlist\nA list of VowelMeasurements\n\n\nvowel_system\nVowelClassCollection\nA the containing vowel system\n\n\nwinners\nlist[fasttrackpy.OneTrack]\nA list of winner OneTracks from the vowel class\n\n\nwinner_params\nnp.array\nAn np.array of winner DCT parameters from the vowel class.",
    "crumbs": [
      "Vowel Measurements",
      "VowelClass"
    ]
  },
  {
    "objectID": "reference/VowelClass.html#methods",
    "href": "reference/VowelClass.html#methods",
    "title": "VowelClass",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_tracks_df\nReturn DataFrame of formanttracks.\n\n\nto_param_df\nReturn DataFrame of formant DCT parameters.\n\n\nto_point_df\nReturn a DataFrame of point measurements\n\n\n\n\n\nVowelClass.to_tracks_df()\nReturn DataFrame of formanttracks.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of formant tracks\n\n\n\n\n\n\n\nVowelClass.to_param_df(output='log_param')\nReturn DataFrame of formant DCT parameters.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of formant DCT parameters\n\n\n\n\n\n\n\nVowelClass.to_point_df()\nReturn a DataFrame of point measurements\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of vowel point measures.",
    "crumbs": [
      "Vowel Measurements",
      "VowelClass"
    ]
  },
  {
    "objectID": "reference/SpeakerCollection.html",
    "href": "reference/SpeakerCollection.html",
    "title": "SpeakerCollection",
    "section": "",
    "text": "SpeakerCollection(self, track_list)\nA class to represent the vowel system of all speakers in a TextGrid.\n\n\nIt is a subclass of defaultdict, and can be keyed by the (file_name, group_name) tuple.\nvowel_measurements = [VowelMeasurement(t) for t in fasttrack_tracks]\nspeakers = SpeakerCollection(vowel_measurements)\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrack_list\nlist[VowelMeasurement]\nA list of VowelMeasurements.\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_tracks_df\nThis will return a data frame of formant\n\n\nto_param_df\nThis will return a dataframe of the DCT parameters for all speakers.\n\n\nto_point_df\nThis will return a DataFrame of point measurements\n\n\n\n\n\nSpeakerCollection.to_tracks_df()\nThis will return a data frame of formant tracks for all speakers.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA dataframe of formant tracks for all speakers.\n\n\n\n\n\n\n\nSpeakerCollection.to_param_df(output='log_param')\nThis will return a dataframe of the DCT parameters for all speakers. If output is passed param, it will be the DCT parameters in the original Hz. If passed log_param, it will be the DCT parameters over log(Hz).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput\nLiteral[‘param’, ‘log_param’]\nWhich set of DCT parameters to return. Defaults to “log_param”.\n'log_param'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of DCT parameters for all speakers.\n\n\n\n\n\n\n\nSpeakerCollection.to_point_df()\nThis will return a DataFrame of point measurements for all speakers Returns: (pl.DataFrame): A DataFrame of vowel point measurements.",
    "crumbs": [
      "Vowel Measurements",
      "SpeakerCollection"
    ]
  },
  {
    "objectID": "reference/SpeakerCollection.html#intended-usage",
    "href": "reference/SpeakerCollection.html#intended-usage",
    "title": "SpeakerCollection",
    "section": "",
    "text": "It is a subclass of defaultdict, and can be keyed by the (file_name, group_name) tuple.\nvowel_measurements = [VowelMeasurement(t) for t in fasttrack_tracks]\nspeakers = SpeakerCollection(vowel_measurements)",
    "crumbs": [
      "Vowel Measurements",
      "SpeakerCollection"
    ]
  },
  {
    "objectID": "reference/SpeakerCollection.html#parameters",
    "href": "reference/SpeakerCollection.html#parameters",
    "title": "SpeakerCollection",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntrack_list\nlist[VowelMeasurement]\nA list of VowelMeasurements.\nrequired",
    "crumbs": [
      "Vowel Measurements",
      "SpeakerCollection"
    ]
  },
  {
    "objectID": "reference/SpeakerCollection.html#methods",
    "href": "reference/SpeakerCollection.html#methods",
    "title": "SpeakerCollection",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_tracks_df\nThis will return a data frame of formant\n\n\nto_param_df\nThis will return a dataframe of the DCT parameters for all speakers.\n\n\nto_point_df\nThis will return a DataFrame of point measurements\n\n\n\n\n\nSpeakerCollection.to_tracks_df()\nThis will return a data frame of formant tracks for all speakers.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA dataframe of formant tracks for all speakers.\n\n\n\n\n\n\n\nSpeakerCollection.to_param_df(output='log_param')\nThis will return a dataframe of the DCT parameters for all speakers. If output is passed param, it will be the DCT parameters in the original Hz. If passed log_param, it will be the DCT parameters over log(Hz).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput\nLiteral[‘param’, ‘log_param’]\nWhich set of DCT parameters to return. Defaults to “log_param”.\n'log_param'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA DataFrame of DCT parameters for all speakers.\n\n\n\n\n\n\n\nSpeakerCollection.to_point_df()\nThis will return a DataFrame of point measurements for all speakers Returns: (pl.DataFrame): A DataFrame of vowel point measurements.",
    "crumbs": [
      "Vowel Measurements",
      "SpeakerCollection"
    ]
  },
  {
    "objectID": "reference/write_data.html",
    "href": "reference/write_data.html",
    "title": "write_data",
    "section": "",
    "text": "write_data(vowel_spaces, destination=Path('.'), which='all', separate=False)\nSave data.\n\n\nThere are multiple data output types, including\n\ntracks: Vowel formant tracks\npoints: Point measurements\nparam: DCT parameters on Hz\nlog_param: DCT parameters on log(Hz)\ntextgrid: The recoded textgrid\n\nBy default, they will all be saved.\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvowel_spaces\nSpeakerCollection\nAn entire SpeakerCollection\nrequired\n\n\ndestination\nstr | Path\nDestination directory. Defaults to Path(\".\").\nPath('.')\n\n\nwhich\nLiteral[‘all’] | list[Literal[‘tracks’, ‘points’, ‘param’, ‘log_param’, ‘textgrid’]]\nWhich data to save. The values are described above. Defaults to “all”.\n'all'\n\n\nseparate\nbool\nWhether or not to write separate .csvs for each individual speaker. Defaults to False.\nFalse",
    "crumbs": [
      "Writers",
      "write_data"
    ]
  },
  {
    "objectID": "reference/write_data.html#parameters",
    "href": "reference/write_data.html#parameters",
    "title": "write_data",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nvowel_spaces\nSpeakerCollection\nAn entire SpeakerCollection\nrequired\n\n\ndestination\nstr | Path\nDestination directory. Defaults to Path(\".\").\nPath('.')\n\n\nwhich\nLiteral[‘all’] | list[Literal[‘tracks’, ‘points’, ‘param’, ‘log_param’, ‘textgrid’]]\nWhich data to save. The values are described above. Defaults to “all”.\n'all'\n\n\nseparate\nbool\nWhether or not to write separate .csvs for each individual speaker. Defaults to False.\nFalse",
    "crumbs": [
      "Writers",
      "write_data"
    ]
  },
  {
    "objectID": "reference/speaker.speaker.Speaker.html",
    "href": "reference/speaker.speaker.Speaker.html",
    "title": "speaker.speaker.Speaker",
    "section": "",
    "text": "speaker.speaker.Speaker(self, arg=None)\nThis is a class to represent speaker information. The argument to Speaker() can be one of\n\nA .yaml file\nA .csv file\nA .xlsx file\nAn old fave .speaker file\n\nWith the exception of the old .speaker files, to work well with new-fave, these speaker files should contain the following fields\n\nfile_name: The file stem of the wav and textgrid files\nspeaker_num: The speaker to be analyzed in a file. the first speaker is 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndf\npl.DataFrame\nA polars data frame of speaker information",
    "crumbs": [
      "Speaker files",
      "speaker.speaker.Speaker"
    ]
  },
  {
    "objectID": "reference/speaker.speaker.Speaker.html#attributes",
    "href": "reference/speaker.speaker.Speaker.html#attributes",
    "title": "speaker.speaker.Speaker",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndf\npl.DataFrame\nA polars data frame of speaker information",
    "crumbs": [
      "Speaker files",
      "speaker.speaker.Speaker"
    ]
  },
  {
    "objectID": "reference/fave_subcorpora.html",
    "href": "reference/fave_subcorpora.html",
    "title": "fave_subcorpora",
    "section": "",
    "text": "fave_subcorpora(subcorpora_glob, speakers=0, speakers_glob=None, include_overlaps=True, recode_rules=None, labelset_parser=None, point_heuristic=None, ft_config='default', fave_aligned=False)\nProcess multiple subcorpora\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubcorpora_glob\nstr | Path\nGlob to subcorpora\nrequired\n\n\nspeakers\n(int, str, Path)\nWhich speaker(s) to produce data for. Can be a numeric index, or a path to a speaker file, or “all”\n0\n\n\nspeakers_glob\nstr\nAlternatively to speakers, a file glob to speaker files.\nNone\n\n\ninclude_overlaps\nbool\nWhether or not to include vowels that are overlapped with speech from other tiers. Defaults to True.\nTrue\n\n\nrecode_rules\nstr | None\nEither a string naming built-in set of recode rules, or path to a custom ruleset. Defaults to None.\nNone\n\n\nlabelset_parser\nstr | None\nEither a string naming a built-in labelset parser, or a path to a custom parser definition. Defaults to None.\nNone\n\n\npoint_heuristic\nstr | None\nEither a string naming a built in point heuristic, or a path to a custom heuristic definition. Defaults to None.\nNone\n\n\nft_config\nstr | None\nEither a string naming a built-in fasttrack config file, or a path to a custom config file. Defaults to “default”.\n'default'\n\n\nfave_aligned\nbool\nWere the textgrids generated by classic FAVE align? Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSpeakerCollection\nA new_fave.SpeakerCollection",
    "crumbs": [
      "Processing Patterns",
      "fave_subcorpora"
    ]
  },
  {
    "objectID": "reference/fave_subcorpora.html#parameters",
    "href": "reference/fave_subcorpora.html#parameters",
    "title": "fave_subcorpora",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsubcorpora_glob\nstr | Path\nGlob to subcorpora\nrequired\n\n\nspeakers\n(int, str, Path)\nWhich speaker(s) to produce data for. Can be a numeric index, or a path to a speaker file, or “all”\n0\n\n\nspeakers_glob\nstr\nAlternatively to speakers, a file glob to speaker files.\nNone\n\n\ninclude_overlaps\nbool\nWhether or not to include vowels that are overlapped with speech from other tiers. Defaults to True.\nTrue\n\n\nrecode_rules\nstr | None\nEither a string naming built-in set of recode rules, or path to a custom ruleset. Defaults to None.\nNone\n\n\nlabelset_parser\nstr | None\nEither a string naming a built-in labelset parser, or a path to a custom parser definition. Defaults to None.\nNone\n\n\npoint_heuristic\nstr | None\nEither a string naming a built in point heuristic, or a path to a custom heuristic definition. Defaults to None.\nNone\n\n\nft_config\nstr | None\nEither a string naming a built-in fasttrack config file, or a path to a custom config file. Defaults to “default”.\n'default'\n\n\nfave_aligned\nbool\nWere the textgrids generated by classic FAVE align? Defaults to False.\nFalse",
    "crumbs": [
      "Processing Patterns",
      "fave_subcorpora"
    ]
  },
  {
    "objectID": "reference/fave_subcorpora.html#returns",
    "href": "reference/fave_subcorpora.html#returns",
    "title": "fave_subcorpora",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nSpeakerCollection\nA new_fave.SpeakerCollection",
    "crumbs": [
      "Processing Patterns",
      "fave_subcorpora"
    ]
  },
  {
    "objectID": "reference/fave_corpus.html",
    "href": "reference/fave_corpus.html",
    "title": "fave_corpus",
    "section": "",
    "text": "fave_corpus(corpus_path, speakers=0, include_overlaps=True, recode_rules=None, labelset_parser=None, point_heuristic=None, ft_config='default', fave_aligned=False)\nProcess a corpus directory.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncorpus_path\nstr | Path\nPath to a corpus directory\nrequired\n\n\nspeakers\n(int, str, Path)\nWhich speaker(s) to produce data for. Can be a numeric index, or a path to a speaker file, or “all”\n0\n\n\ninclude_overlaps\nbool\nWhether or not to include vowels that are overlapped with speech from other tiers. Defaults to True.\nTrue\n\n\nrecode_rules\nstr | None\nEither a string naming built-in set of recode rules, or path to a custom ruleset. Defaults to None.\nNone\n\n\nlabelset_parser\nstr | None\nEither a string naming a built-in labelset parser, or a path to a custom parser definition. Defaults to None.\nNone\n\n\npoint_heuristic\nstr | None\nEither a string naming a built in point heuristic, or a path to a custom heuristic definition. Defaults to None.\nNone\n\n\nft_config\nstr | None\nEither a string naming a built-in fasttrack config file, or a path to a custom config file. Defaults to “default”.\n'default'\n\n\nfave_aligned\nbool\nWere the textgrids generated by classic FAVE align? Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSpeakerCollection\nA new_fave.SpeakerCollection",
    "crumbs": [
      "Processing Patterns",
      "fave_corpus"
    ]
  },
  {
    "objectID": "reference/fave_corpus.html#parameters",
    "href": "reference/fave_corpus.html#parameters",
    "title": "fave_corpus",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncorpus_path\nstr | Path\nPath to a corpus directory\nrequired\n\n\nspeakers\n(int, str, Path)\nWhich speaker(s) to produce data for. Can be a numeric index, or a path to a speaker file, or “all”\n0\n\n\ninclude_overlaps\nbool\nWhether or not to include vowels that are overlapped with speech from other tiers. Defaults to True.\nTrue\n\n\nrecode_rules\nstr | None\nEither a string naming built-in set of recode rules, or path to a custom ruleset. Defaults to None.\nNone\n\n\nlabelset_parser\nstr | None\nEither a string naming a built-in labelset parser, or a path to a custom parser definition. Defaults to None.\nNone\n\n\npoint_heuristic\nstr | None\nEither a string naming a built in point heuristic, or a path to a custom heuristic definition. Defaults to None.\nNone\n\n\nft_config\nstr | None\nEither a string naming a built-in fasttrack config file, or a path to a custom config file. Defaults to “default”.\n'default'\n\n\nfave_aligned\nbool\nWere the textgrids generated by classic FAVE align? Defaults to False.\nFalse",
    "crumbs": [
      "Processing Patterns",
      "fave_corpus"
    ]
  },
  {
    "objectID": "reference/fave_corpus.html#returns",
    "href": "reference/fave_corpus.html#returns",
    "title": "fave_corpus",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nSpeakerCollection\nA new_fave.SpeakerCollection",
    "crumbs": [
      "Processing Patterns",
      "fave_corpus"
    ]
  },
  {
    "objectID": "reference/fave_audio_textgrid.html",
    "href": "reference/fave_audio_textgrid.html",
    "title": "fave_audio_textgrid",
    "section": "",
    "text": "fave_audio_textgrid(audio_path, textgrid_path, speakers=0, include_overlaps=True, recode_rules=None, labelset_parser=None, point_heuristic=None, ft_config='default', fave_aligned=False)\nProcess a single audio/textgrid pair.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naudio_path\nstr | Path\nPath to an audio file\nrequired\n\n\ntextgrid_path\nstr | Path\nPath to a textgrid\nrequired\n\n\nspeakers\nint | list[int] | str | Path | optional\nWhich speaker(s) to produce data for. Can be a numeric index, or a path to a speaker file, or “all”\n0\n\n\ninclude_overlaps\nbool\nWhether or not to include vowels that are overlapped with speech from other tiers. Defaults to True.\nTrue\n\n\nrecode_rules\nstr | None\nEither a string naming built-in set of recode rules, or path to a custom ruleset. Defaults to None.\nNone\n\n\nlabelset_parser\nstr | None\nEither a string naming a built-in labelset parser, or a path to a custom parser definition. Defaults to None.\nNone\n\n\npoint_heuristic\nstr | None\nEither a string naming a built in point heuristic, or a path to a custom heuristic definition. Defaults to None.\nNone\n\n\nft_config\nstr | None\nEither a string naming a built-in fasttrack config file, or a path to a custom config file. Defaults to “default”.\n'default'\n\n\nfave_aligned\nbool\nWere the textgrids generated by classic FAVE align? Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSpeakerCollection\nA new_fave.SpeakerCollection",
    "crumbs": [
      "Processing Patterns",
      "fave_audio_textgrid"
    ]
  },
  {
    "objectID": "reference/fave_audio_textgrid.html#parameters",
    "href": "reference/fave_audio_textgrid.html#parameters",
    "title": "fave_audio_textgrid",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\naudio_path\nstr | Path\nPath to an audio file\nrequired\n\n\ntextgrid_path\nstr | Path\nPath to a textgrid\nrequired\n\n\nspeakers\nint | list[int] | str | Path | optional\nWhich speaker(s) to produce data for. Can be a numeric index, or a path to a speaker file, or “all”\n0\n\n\ninclude_overlaps\nbool\nWhether or not to include vowels that are overlapped with speech from other tiers. Defaults to True.\nTrue\n\n\nrecode_rules\nstr | None\nEither a string naming built-in set of recode rules, or path to a custom ruleset. Defaults to None.\nNone\n\n\nlabelset_parser\nstr | None\nEither a string naming a built-in labelset parser, or a path to a custom parser definition. Defaults to None.\nNone\n\n\npoint_heuristic\nstr | None\nEither a string naming a built in point heuristic, or a path to a custom heuristic definition. Defaults to None.\nNone\n\n\nft_config\nstr | None\nEither a string naming a built-in fasttrack config file, or a path to a custom config file. Defaults to “default”.\n'default'\n\n\nfave_aligned\nbool\nWere the textgrids generated by classic FAVE align? Defaults to False.\nFalse",
    "crumbs": [
      "Processing Patterns",
      "fave_audio_textgrid"
    ]
  },
  {
    "objectID": "reference/fave_audio_textgrid.html#returns",
    "href": "reference/fave_audio_textgrid.html#returns",
    "title": "fave_audio_textgrid",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nSpeakerCollection\nA new_fave.SpeakerCollection",
    "crumbs": [
      "Processing Patterns",
      "fave_audio_textgrid"
    ]
  },
  {
    "objectID": "index.html#what-is-new-fave",
    "href": "index.html#what-is-new-fave",
    "title": "new-fave",
    "section": "What is new-fave?",
    "text": "What is new-fave?\nnew-fave is a tool for automating and optimizing vowel formant extraction. It is philosophically similar (and named after) the FAVE-suite. However, new-fave has been completely written from scratch, and has some key differences from the FAVE-suite.\n\nnew-fave does not include a forced-aligner. It can process alignments produced by fave-align, but we would recommend using the Monteal Forced Aligner instead\nnew-fave does not require speaker demographics. You can optionally pass fave-extract a speaker demographics file to be merged into your formant data, but this does not influence how the data is processed in any way. Besides including file name and speaker number data, you can pass any demographic information you would like.\nnew-fave does not assume North American English vowels. Your alignments can contain any set of vowels, in any transcription system, as long as you can provide a regular expression to identify them.\nnew-fave is customizable. With config files, you can customize vowel recoding, labelset parsing, and point measurement heuristics.\nnew-fave is focused on formant tracks. You can still produce single point measurements for vowels, but new-fave is built upon the FastTrack method. By default, it will write output files including point measurements, full formant tracks, and Discrete Cosine Transform coefficients.\nnew-fave is maintainable. As time goes on, and the code base needs updating, the organization and infrastructure of new-fave should allow it to be readilly updateable.\n\nYou can read more on the getting started page.",
    "crumbs": [
      "Home",
      "new-fave"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "new-fave",
    "section": "Installation",
    "text": "Installation\nYou can install new-fave with pip.\n# bash\npip install new-fave",
    "crumbs": [
      "Home",
      "new-fave"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "new-fave",
    "section": "Usage",
    "text": "Usage\nTo use the default settings (which assume CMU dictionary transcriptions), you can use one of these patterns.\n\nA single audio + textgrid pair\n# bash\nfave-extract audio-textgrid speaker1.wav speaker1.TextGrid\n\n\nA directory of audio + textgrid pairs\n# bash\nfave-extract corpus speakers/\n\n\nMultiple subdirectories of audio + textgrid pairs\n# bash\nfave-extract subcorpora data/*",
    "crumbs": [
      "Home",
      "new-fave"
    ]
  },
  {
    "objectID": "dev_plan/index.html",
    "href": "dev_plan/index.html",
    "title": "Development Plan",
    "section": "",
    "text": "The plan is for new-fave to be more opinionated about the input data stucture. fasttrackpy is more general purpose and therefore has its own design approach.\n\n\n\nThe plan is for new-fave to bring together, under one tool\n\nfave-recodeing of input data, allowing for dialect, language, or research question specific recoding of alignment output\nCustomizable point measurement heuristics\nEnriched data output enabled by its opinionated approach to data input. (e.g. fave-syllabify)\n\n\n\n\nSee New-Fave Approach"
  },
  {
    "objectID": "dev_plan/index.html#what-is-favey-about-this",
    "href": "dev_plan/index.html#what-is-favey-about-this",
    "title": "Development Plan",
    "section": "",
    "text": "The plan is for new-fave to be more opinionated about the input data stucture. fasttrackpy is more general purpose and therefore has its own design approach.\n\n\n\nThe plan is for new-fave to bring together, under one tool\n\nfave-recodeing of input data, allowing for dialect, language, or research question specific recoding of alignment output\nCustomizable point measurement heuristics\nEnriched data output enabled by its opinionated approach to data input. (e.g. fave-syllabify)\n\n\n\n\nSee New-Fave Approach"
  }
]