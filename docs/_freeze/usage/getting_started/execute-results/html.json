{
  "hash": "368e21f00c32ce7e956f6ae5b9c3681d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Getting Started\ndescription: Command-Line Usage\nengine: knitr\norder: 1\nresources: \n    - data/*\n    - my_corpus/*\n    - big_project/*\n---\n\nWe expect new-fave to be primarily used as a command-line tool. This page outlines that usage. Using new-fave this way does not require you to do any python programming, but if you would like to import new-fave into a python project of your own, see the page on [Python Usage](python_usage.qmd).\n\n# Installation\n\nTo use new-fave, you will need to have python installed on your computer. Currently, new-fave supports python versions {{< var python >}}. If you are not sure whether python is installed, or what version is installed, [here is a good tutorial for figuring that out](https://realpython.com/installing-python/).\n\n::: callout-tip\nIn this documentation, when code is meant to be run at the command line, the code snippet will begin with `# command-line`\n:::\n\nOnce you have python successfully installed, you can install new-fave at the command-line like so:\n\n``` bash\n# command-line\npip install new-fave\n```\n\n# Usage\n\n::: callout-tip\n## Command Builder\n\n[The Command Builder](../command/) tool can help you put together a new-fave command.\n:::\n\nAfter installing new-fave, the `fave-extract` executable will be made available. You can access a minimal help message by just running `fave-extract` with no arguments.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# command-line\nfave-extract\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUsage: fave-extract [OPTIONS] COMMAND [ARGS]...\n\n  Run new fave-extract\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  audio-textgrid (audio-textgrid)\n                           Run fave-extract on a single audio+textgrid pair.\n  corpus (corpus)          Run fave-extract on a directory of audio+textgrid...\n  subcorpora (subcorpora)  Run fave-extract on multiple subdirectories.\n```\n\n\n:::\n:::\n\n\n`fave-extract` has three sub-commands. Which one you use will depend on how your data is organized.\n\n-   [`fave-extract audio-textgrid`](#audio-textgrid)\n\n    -   For when you have a single audio file and force-aligned textgrid pair to process.\n\n-   [`fave-extract corpus`](#corpus)\n\n    -   For when you have all of you audio files and force-aligned textgrids in a single directory.\n\n-   [`fave-extract subcorpora`](#subcorpora)\n\n    -   For when your audio file and textgrid pairs are each in their own directory, inside of a larger directory.\n\n## audio-textgrid {#audio-textgrid}\n\nIn the simplest case of a single audio/textgrid pair, your best option is the audio-textgrid subcommand. For example, if you had the following files in a `data/` directory:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\ndata\n├── speaker1.TextGrid\n└── speaker1.wav\n```\n\n\n:::\n:::\n\n\nTo use all default settings, you would run the following:\n\n``` bash\n# command-line\nfave-extract audio-textgrid data/speaker1.wav data/speaker1.TextGrid\n```\n\nTo customize the way `fave-extract audio-textgrid` works, including how to incorporate speaker demographics into the output, see [the customization documentation](customization/).\n\n## corpus {#corpus}\n\nIf you have all of your audio file/textgrid pairs in a single directory, then the corpus subcommand is your best option. An example file organization would look like this:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nmy_corpus\n├── recordingA.TextGrid\n├── recordingA.wav\n├── recordingB.TextGrid\n└── recordingB.wav\n```\n\n\n:::\n:::\n\n\n::: callout-important\n## File Naming\n\nThe corpus subcommand will only work if the file names are the *the same* for the audio/textgrid pairs. That is, if your audio files are named something like `speaker1.wav`, and your textgrids are named something like `speaker1_aligned.TextGrid`, the corpus subcommand won't process them.\n:::\n\nTo use all default settings, you would run the following:\n\n``` bash\n# command-line\nfave-extract corpus my_corpus/\n```\n\nTo customize the way `fave-extract corpus` works, including how to incorporate speaker demographics into the output, see [the customization documentation](customizating/).\n\n## subcorpora {#subcorpora}\n\nIf each audio file/textgrid pair is in its own directory inside of a larger project directory, then the subcorpora subcommand is the best to use. An example file organization would look like this:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nbig_project\n├── speaker1\n│   ├── notes.txt\n│   ├── speaker1.TextGrid\n│   └── speaker1.wav\n└── speaker2\n    ├── notes.txt\n    ├── speaker2.TextGrid\n    └── speaker2.wav\n```\n\n\n:::\n:::\n\n\n::: callout-important\n## File Naming\n\nThe corpus subcommand will only work if the file names are the *the same* for the audio/textgrid pairs. That is, if your audio files are named something like `speaker1.wav`, and your textgrids are named something like `speaker1_aligned.TextGrid`, the corpus subcommand won't process them.\n:::\n\nTo use all default settings, you would run the following:\n\n``` bash\n# command-line\nfave-extract subcorpora big_project/speaker*\n```\n\nTo customize the way `fave-extract subcorpora` works, including how to incorporate speaker demographics into the output, see [the customization documentation](customization/).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}